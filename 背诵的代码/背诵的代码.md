# 第二章

## 快速排序

```c++
void quickSort1(int a[], int l, int r)
{
	if (l >= r)
	{
		return;	
	} 
	int j = partition(a,l,r);
	quickSort1(a, l, j - 1);
	quickSort1(a, j + 1, r);
}

int partition(int a[],int l,int r)
{
	int i = l;
	int j = r+1;
	int x = a[l];
	while(1)
	{
		while(a[++i]<x && i<r);
		while(a[--j]>x);
		if(i>=j) break;
		int temp = a[i];
		a[i] = a[j];
		a[j] = temp;
	}
	
	a[l] = a[j];
	a[j] = x;
	return j;
}

int partitionRandom(int a[],int l,int r)
{
	int index = l+rand()%(r-l+1);
	int temp = a[l];
	a[l] = a[index];
	a[index] = temp;
	int i = l;
	int j = r+1;
	int x = a[l];
	while(1)
	{
		while(a[++i]<x && i<r);
		while(a[--j]>x);
		if(i>=j) break;
		temp = a[i];
		a[i] = a[j];
		a[j] = temp;
	}
	
	a[l] = a[j];
	a[j] = x;
	return j;
}
```

## 合并排序
### 递归

```c++
void mergeSortR(int a[], int l, int r)//int level)
{
	if (l >= r)
	{
		return;
	} 
	int mid = (l + r) >> 1;
   	mergeSortR(a,l,mid);
    mergeSortR(a,mid+1,r);
	mergeWithCopy(a, temp, l, r, mid);
}

void mergeWithCopy(int a[], int temp[], int l, int r, int mid)
{
	int i, j, k;
	i = l;
	j = mid + 1;
	k = l;
	while (i <= mid && j <= r)
	{
		if (a[i] < a[j]) temp[k++] = a[i++];
		else temp[k++] = a[j++];
	}
	while (i <= mid)
	{
		temp[k++] = a[i++];
	}
	while (j <= r)
	{
		temp[k++] = a[j++];
	}

	for (int i = l, j = l; i <= r; ++i, ++j)
	{
		a[i] = temp[j];
	}
}
```

### 非递归

![image-20211205203222368](背诵的代码.assets/image-20211205203222368.png)

![image-20211205203313506](背诵的代码.assets/image-20211205203313506.png)

## 线性时间选择

![image-20211205203403585](背诵的代码.assets/image-20211205203403585.png)

## 平面最近点对

### 一维的情况

![image-20211206200715386](背诵的代码.assets/image-20211206200715386.png)

### 二维的情况

<img src="背诵的代码.assets/image-20211206202601205.png" alt="image-20211206202601205" style="zoom:50%;" />

![image-20211206202410247](背诵的代码.assets/image-20211206202410247.png)

![image-20211206220859638](背诵的代码.assets/image-20211206220859638.png)

![image-20211206221120356](背诵的代码.assets/image-20211206221120356.png)

![image-20211206221131304](背诵的代码.assets/image-20211206221131304.png)

![image-20211206221141024](背诵的代码.assets/image-20211206221141024.png)





# 第三章-动态规划

## 注意

- 代码10分（最优解5分，最优解构造5分），分析算法的**复杂度**分析5分，**递推式式子**5分等等都要算分。
- 判断最优子结构性质
- 状态转移方程
  - 边界条件
  - 其他情况

- 最优解是什么(值 和 串到底是什么)
- 代码

## 最优子结构性质

![image-20211206210730434](背诵的代码.assets/image-20211206210730434.png)

## 重叠子问题性质

![image-20211206211025280](背诵的代码.assets/image-20211206211025280.png)

## 矩阵连乘

## 最长公共子序列

![image-20211206212028302](背诵的代码.assets/image-20211206212028302.png)

![image-20211206215728680](背诵的代码.assets/image-20211206215728680.png)

![image-20211206213627920](背诵的代码.assets/image-20211206213627920.png)

![image-20211206212045308](背诵的代码.assets/image-20211206212045308.png)

==第一行应该是i等于0或者j等于0==

![image-20211206212139926](背诵的代码.assets/image-20211206212139926.png)

## 凸多边形三角剖分

![image-20211206212517348](背诵的代码.assets/image-20211206212517348.png)

![image-20211206212533469](背诵的代码.assets/image-20211206212533469.png)

应该是$k < j$

![image-20211206212552889](背诵的代码.assets/image-20211206212552889.png)



# 第五章

## 子集树

<img src="背诵的代码.assets/image-20211206180037691.png" alt="image-20211206180037691" style="zoom:50%;" />

时间复杂度$O(2^n)$

## 排列树

<img src="背诵的代码.assets/image-20211206180230257.png" alt="image-20211206180230257" style="zoom:50%;" />

时间复杂度$O(n!)$

